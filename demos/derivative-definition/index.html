<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Derivative: Secant to Tangent • Autodiff4Astro</title>
  <meta name="description" content="Interactive illustration of the derivative as the limit of secant slopes using JSXGraph." />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <!-- JSXGraph CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css">
  <script src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
  <style>
    /* CNRS palette */
    :root{
      --cnrs-blue: #00274b;
      --cnrs-cyan: #0099cc;
      --cnrs-gray: #5c5c5c;
      --cnrs-gray-light: #999999;
      --cnrs-purple: #6841eb;
      --cnrs-yellow: #feeb6d;
      --cnrs-white: #ffffff;
      /* Derived */
      --text: var(--cnrs-blue);
      --muted: var(--cnrs-gray);
    }
    *{ box-sizing:border-box }
  html,body{ height:100%; margin:0; background:transparent; color:var(--text); font:21px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial }
    /* Make JSXGraph board background transparent for seamless embedding */
    .jxgbox{ background:transparent !important; }
  .wrap{ display:flex; flex-direction:column; gap:12px; padding:12px; height:100svh; background:transparent }
  header{ display:flex; align-items:center; justify-content:space-between; gap:12px }
  /* Top-left compact control */
  .top-controls{ display:flex; align-items:center; gap:8px }
  .top-controls label{ color:var(--muted); font-size:18px }
    header .hint{ color:var(--muted) }
    .board{ flex:1; min-height:280px; border-radius:8px; overflow:hidden; border:none; background:transparent }
    .controls{ display:grid; gap:8px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); align-items:end }
    .control{ padding:10px; border:1px solid var(--cnrs-gray-light); border-radius:10px; background:transparent }
  .control label{ display:block; color:var(--muted); font-size:18px; margin-bottom:6px }
    input[type="range"]{ width:100% }
  .kbd{ font:18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:var(--cnrs-white); color:var(--text); border:1px solid var(--cnrs-gray-light); padding:1px 6px; border-radius:6px }
    .legend{ display:flex; gap:12px; align-items:center; color:var(--muted) }
    .chip{ display:inline-flex; gap:6px; align-items:center }
    .dot{ width:10px; height:10px; border-radius:50% }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="top-controls">
        <label for="fn-select">Function f(x)</label>
        <select id="fn-select">
          <option value="sin">f(x) = sin(x)</option>
          <option value="cubic">f(x) = 0.1 x^3 - x</option>
          <option value="gauss">f(x) = exp(-x^2/2)</option>
          <option value="abs">f(x) = |x| (kink)</option>
          <option value="kink">f(x) = |x| + 0.2 x^2 (kink)</option>
        </select>
      </div>
      <div class="legend">
        <span class="chip"><span class="dot" style="background:#0099cc"></span> f(x)</span>
  <span class="chip"><span class="dot" style="background:#6841eb"></span> secant slope (Δy/ε)</span>
        <span class="chip"><span class="dot" style="background:#00274b"></span> tangent slope f'(x)</span>
      </div>
    </header>

    <div id="jxg-board" class="board"></div>

    <section class="controls">
  <!-- function selector moved to header to free space here -->
      <div class="control">
        <label>Point x (drag the blue point or use slider)</label>
        <input id="x-slider" type="range" min="-3.14" max="3.14" step="0.001" value="0.8" />
      </div>
      <div class="control">
  <label>ε (secant offset). Tip: press <span class="kbd">A</span> to auto-animate</label>
        <input id="h-slider" type="range" min="-2" max="2" step="0.0005" value="1.2" />
      </div>
      <div class="control">
        <label>Precision readout</label>
        <div id="readout" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <script>
  (function(){
    // Functions and derivatives
    function makeFns(kind){
      if(kind==='sin') return {
        f: x => Math.sin(x),
        df: x => Math.cos(x),
        view: [-4, 4, -2.2, 2.2],
        tick: Math.PI/2
      };
      if(kind==='cubic') return {
        f: x => 0.1*x*x*x - x,
        df: x => 0.3*x*x - 1,
        view: [-4, 4, -4, 4],
        tick: 1
      };
      if(kind==='gauss') return {
        f: x => Math.exp(-0.5*x*x),
        df: x => -x*Math.exp(-0.5*x*x),
        view: [-3.5, 3.5, -0.2, 1.5],
        tick: 1
      };
      if(kind==='abs') return {
        f: x => Math.abs(x),
        df: x => (x < 0 ? -1 : x > 0 ? 1 : NaN), // undefined at 0
        view: [-3, 3, -0.5, 3],
        tick: 1
      };
      if(kind==='kink') return {
        f: x => Math.abs(x) + 0.2*x*x,
        df: x => (x < 0 ? -1 + 0.4*x : x > 0 ? 1 + 0.4*x : NaN), // undefined at 0
        view: [-3, 3, -0.5, 4],
        tick: 1
      };
      return makeFns('sin');
    }

  // DOM
    const boardDiv = document.getElementById('jxg-board');
    const select = document.getElementById('fn-select');
    const xSlider = document.getElementById('x-slider');
    const hSlider = document.getElementById('h-slider');
    const readout = document.getElementById('readout');

    // State
    let kind = select.value;
    let { f, df, view, tick } = makeFns(kind);
    let x0 = parseFloat(xSlider.value);
    let h = parseFloat(hSlider.value);
    let animId = null;

  // Theme colors (CNRS palette)
    const COLORS = {
      fx: '#0099cc',       // CNRS cyan
      secant: '#6841eb',   // CNRS purple
      tangent: '#00274b',  // CNRS blue
      seg: '#6841eb',      // Δx/Δy segments
      axis: '#5c5c5c'      // CNRS gray
    };

  // Build board
    let brd = JXG.JSXGraph.initBoard('jxg-board', {
      boundingbox: [view[0], view[3], view[1], view[2]],
      axis:false, showCopyright:false, showNavigation:false,
      keepaspectratio:false
    });

    // Axes
  const xAxis = brd.create('axis', [[0,0],[1,0]], { strokeColor: COLORS.axis, ticks: { visible:true, ticksDistance: tick, minorTicks: 1, strokeColor: COLORS.axis, label: { strokeColor: COLORS.axis } } });
  const yAxis = brd.create('axis', [[0,0],[0,1]], { strokeColor: COLORS.axis, ticks: { visible:true, ticksDistance: tick, minorTicks: 1, strokeColor: COLORS.axis, label: { strokeColor: COLORS.axis } } });

  // Graph of f and geometric elements (use let so we can rebuild)
  let curve = brd.create('functiongraph', [f, view[0], view[1]], { strokeColor: COLORS.fx, strokeWidth:3 });

  // Points x and x+h on the curve
  let A = brd.create('glider', [x0, f(x0), curve], {withLabel:false, strokeColor:COLORS.fx, fillColor:COLORS.fx});
  let B = brd.create('point', [() => A.X()+h, () => f(A.X()+h)], {withLabel:false, strokeColor:COLORS.secant, fillColor:COLORS.secant});

  // Secant line through A and B
  let secant = brd.create('line', [A, B], { strokeColor:COLORS.secant, strokeWidth:2 });

  // Tangent at A (custom): hide when derivative is undefined (e.g., kink)
  let tangent = brd.create('line', [
    () => [A.X(), f(A.X())],
    () => {
      const s = df(A.X());
      const dx = 1; // step on x for direction
      return [A.X()+dx, f(A.X()) + (isFinite(s) ? s*dx : 0)];
    }
  ], { strokeColor:COLORS.tangent, strokeWidth:2, visible: () => isFinite(df(A.X())) });

  // Visual delta x and delta y segment
  let dxSeg = brd.create('segment', [[() => A.X(), () => f(A.X())], [() => B.X(), () => f(A.X())]], { strokeColor:COLORS.seg, dash:2 });
  let dySeg = brd.create('segment', [[() => B.X(), () => f(A.X())], [() => B.X(), () => f(B.X())]], { strokeColor:COLORS.seg, dash:2 });

    // Draggable x along x-axis synchronized with slider
    const XaxisPoint = brd.create('point', [x0, 0], { withLabel:false, visible:false });
    brd.on('mousemove', () => { /* keep interactive feeling smooth */ });

    // Keep A on curve when sliding x0
    function setX(val){ x0 = val; if(A) A.moveTo([x0, f(x0)]); brd.update(); updateReadout(); }
    function setH(val){ h = val; brd.update(); updateReadout(); }

    function syncXSliderRange(){
      xSlider.min = view[0];
      xSlider.max = view[1];
      // keep value in range
      if(x0 < view[0]) x0 = view[0];
      if(x0 > view[1]) x0 = view[1];
      xSlider.value = x0;
    }

    xSlider.addEventListener('input', e => setX(parseFloat(e.target.value)));
    hSlider.addEventListener('input', e => setH(parseFloat(e.target.value)));

    // Allow dragging point A along the curve and sync slider
    A.on('drag', () => { xSlider.value = A.X().toFixed(3); setX(A.X()); });

    // Keyboard: A toggles auto-animate h → 0
    window.addEventListener('keydown', (e) => {
      if(e.key.toLowerCase() === 'a') toggleAnim();
    });

    function toggleAnim(){
      if(animId){ cancelAnimationFrame(animId); animId = null; return; }
      const speed = 0.98; // shrink factor per frame
      const sign = h >= 0 ? 1 : -1;
      function step(){
        // asymptotically approach 0 with a floor to avoid NaN
        h = (Math.abs(h) < 1e-4) ? 1.5*sign : h*speed;
        hSlider.value = h;
        brd.update();
        updateReadout();
        animId = requestAnimationFrame(step);
      }
      animId = requestAnimationFrame(step);
    }

    function slopeSecant(){ return (f(x0+h)-f(x0))/h; }

    function updateReadout(){
      const sSec = isFinite(h) && Math.abs(h) > 1e-12 ? slopeSecant() : NaN;
      const sTan = df(x0);
      const err = isFinite(sSec) ? Math.abs(sSec - sTan) : NaN;
  readout.innerHTML = `x = ${x0.toFixed(3)} | ε = ${h.toExponential(2)}<br>`+
        `secant slope ≈ <span style="color:${COLORS.secant}">${(sSec).toFixed(4)}</span><br>`+
        `tangent slope = <span style="color:${COLORS.tangent}">${(sTan).toFixed(4)}</span><br>`+
        `|error| = ${isNaN(err)?'—':err.toExponential(2)}`;
    }

    function rebuild(newKind){
      kind = newKind; ({ f, df, view, tick } = makeFns(kind));
      syncXSliderRange();
      // Reset board with new view
      JXG.JSXGraph.freeBoard(brd);
      brd = JXG.JSXGraph.initBoard('jxg-board', {
        boundingbox: [view[0], view[3], view[1], view[2]],
        axis:false, showCopyright:false, showNavigation:false,
        keepaspectratio:false
      });
      // Axes
  brd.create('axis', [[0,0],[1,0]], { strokeColor: COLORS.axis, ticks: { visible:true, ticksDistance: tick, minorTicks: 1, strokeColor: COLORS.axis, label: { strokeColor: COLORS.axis } } });
  brd.create('axis', [[0,0],[0,1]], { strokeColor: COLORS.axis, ticks: { visible:true, ticksDistance: tick, minorTicks: 1, strokeColor: COLORS.axis, label: { strokeColor: COLORS.axis } } });
      // Curve and geometry (recreate to avoid stale references)
  curve = brd.create('functiongraph', [f, view[0], view[1]], { strokeColor: COLORS.fx, strokeWidth:3 });
  A = brd.create('glider', [x0, f(x0), curve], {withLabel:false, strokeColor:COLORS.fx, fillColor:COLORS.fx});
  B = brd.create('point', [() => A.X()+h, () => f(A.X()+h)], {withLabel:false, strokeColor:COLORS.secant, fillColor:COLORS.secant});
  secant = brd.create('line', [A, B], { strokeColor:COLORS.secant, strokeWidth:2 });
  // Recreate tangent with custom visibility
  tangent = brd.create('line', [
    () => [A.X(), f(A.X())],
    () => {
      const s = df(A.X());
      const dx = 1;
      return [A.X()+dx, f(A.X()) + (isFinite(s) ? s*dx : 0)];
    }
  ], { strokeColor:COLORS.tangent, strokeWidth:2, visible: () => isFinite(df(A.X())) });
  dxSeg = brd.create('segment', [[() => A.X(), () => f(A.X())], [() => B.X(), () => f(A.X())]], { strokeColor:COLORS.seg, dash:2 });
  dySeg = brd.create('segment', [[() => B.X(), () => f(A.X())], [() => B.X(), () => f(B.X())]], { strokeColor:COLORS.seg, dash:2 });
      // Rebind drag behavior
      A.on('drag', () => { xSlider.value = A.X().toFixed(3); x0 = A.X(); brd.update(); updateReadout(); });
      updateReadout();
    }

    select.addEventListener('change', e => rebuild(e.target.value));

  // Initial paint
  syncXSliderRange();
    updateReadout();

  // Note: Avoid ResizeObserver loops which can cause jitter in some embeds.
  // If you need dynamic resizing, prefer a debounced window resize handler.
  // window.addEventListener('resize', JXG.JSXGraph.Utils.debounce(() => {
  //   brd.resizeContainer(boardDiv.clientWidth, boardDiv.clientHeight);
  //   brd.update();
  // }, 100));
  })();
  </script>
</body>
</html>
